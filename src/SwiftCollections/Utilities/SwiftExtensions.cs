using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

namespace SwiftCollections
{
    /// <summary>
    /// Provides extension methods for collection manipulation and utility functions.
    /// </summary>
    public static class SwiftExtensions
    {
        /// <summary>
        /// Populates an array with values generated by a specified provider function.
        /// </summary>
        /// <typeparam name="T">The type of the elements in the array.</typeparam>
        /// <param name="array">The array to populate.</param>
        /// <param name="provider">A function that generates a value for each element in the array.</param>
        /// <returns>The populated array.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T[] Populate<T>(this T[] array, Func<T> provider)
        {
            for (int i = 0; i < array.Length; i++)
                array[i] = provider();
            return array;
        }

        /// <summary>
        /// Populates an array with values generated by a provider function that accepts the current index.
        /// </summary>
        /// <typeparam name="T">The type of the elements in the array.</typeparam>
        /// <param name="array">The array to populate.</param>
        /// <param name="provider">A function that generates a value for each element based on its index.</param>
        /// <returns>The populated array.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T[] Populate<T>(this T[] array, Func<int, T> provider)
        {
            for (int i = 0; i < array.Length; i++)
                array[i] = provider(i);
            return array;
        }

        /// <summary>
        /// Populates an array with new instances of the specified type. 
        /// The type must have a parameterless constructor.
        /// </summary>
        /// <typeparam name="T">The type of the elements in the array.</typeparam>
        /// <param name="array">The array to populate.</param>
        /// <returns>The populated array.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T[] Populate<T>(this T[] array) where T : new()
        {
            for (int i = 0; i < array.Length; i++)
                array[i] = new T();
            return array;
        }

        /// <summary>
        /// Attempts to retrieve an element from the array at the specified index.
        /// Returns true if the index is valid and the element is retrieved; otherwise, returns false.
        /// </summary>
        /// <typeparam name="T">The type of elements in the array.</typeparam>
        /// <param name="array">The array from which to retrieve the element.</param>
        /// <param name="index">The index of the element to retrieve.</param>
        /// <param name="result">
        /// When this method returns, contains the element at the specified index if the index is valid;
        /// otherwise, the default value for the type of the element.
        /// </param>
        /// <returns>
        /// True if the element at the specified index was retrieved successfully; otherwise, false.
        /// </returns>
        public static bool TryIndex<T>(this T[] array, int index, out T result)
        {
            if (array != null)
            {
                if (index < 0)
                {
                    // Support negative indices to access elements from the end
                    index = array.Length + index;
                }
                if (index >= 0 && index < array.Length)
                {
                    result = array[index];
                    return true;
                }
            }
            result = default;
            return false;
        }

        /// <summary>
        /// An iterator that yields the elements of the source collection in a random order using the specified random number generator.
        /// </summary>
        /// <typeparam name="T">The type of elements in the collection.</typeparam>
        /// <param name="source">The collection to shuffle.</param>
        /// <param name="rng">The random number generator to use for shuffling.</param>
        /// <returns>An iterator that yields the shuffled elements.</returns>
        public static IEnumerable<T> Shuffle<T>(this IEnumerable<T> source, Random rng)
        {
            if (source == null) ThrowHelper.ThrowArgumentNullException("source");
            if (rng == null) ThrowHelper.ThrowArgumentNullException("rng");

            SwiftList<T> buffer = new SwiftList<T>(source);
            int n = buffer.Count;
            while (n > 0)
            {
                int k = rng.Next(n);
                n--;
                // Swap the selected element with the last unshuffled element
                (buffer[k], buffer[n]) = (buffer[n], buffer[k]);
                yield return buffer[n];
            }
        }

        /// <summary>
        /// Shuffles the elements of the list in place using the specified random number generator.
        /// </summary>
        /// <typeparam name="T">The type of elements in the list.</typeparam>
        /// <param name="list">The list to shuffle.</param>
        /// <param name="rng">The random number generator to use for shuffling.</param>
        public static void ShuffleInPlace<T>(this IList<T> list, Random rng)
        {
            if (list == null) ThrowHelper.ThrowArgumentNullException(nameof(list));
            if (rng == null) ThrowHelper.ThrowArgumentNullException(nameof(rng));

            int n = list.Count;
            while (n > 1)
            {
                n--;
                int k = rng.Next(n + 1);
                (list[n], list[k]) = (list[k], list[n]);
            }
        }

        /// <summary>
        /// Determines whether a sequence contains any elements.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="source"> The <see cref="IEnumerable{T}"/> to check for emptiness.</param>
        /// <returns>
        /// true if the source sequence contains any elements; otherwise, false.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsPopulated<T>(this IEnumerable<T> source)
        {
            if(source == null) return ThrowHelper.ThrowArgumentNullException<bool>(nameof(source));
            using IEnumerator<T> enumerator = source.GetEnumerator();
            return enumerator.MoveNext();
        }

        /// <summary>
        /// Determines whether the collection is not null and contains any elements.
        /// </summary>
        /// <typeparam name="T">The type of elements in the collection.</typeparam>
        /// <param name="source">The collection to check.</param>
        /// <returns>
        /// True if the collection is not null and contains at least one element; otherwise, false.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsPopulatedSafe<T>(this IEnumerable<T> source) => source != null && source.IsPopulated();

        /// <summary>
        /// Gets the element at the specified index from the end (1-based).
        /// For example, FromEnd(1) returns the last item, FromEnd(2) returns second-to-last.
        /// </summary>
        public static T FromEnd<T>(this IEnumerable<T> source, int reverseIndex)
        {
            if (source is SwiftList<T> swift)
                return swift.FromEnd(reverseIndex);

            // fallback for generic IEnumerable
            var buffer = new SwiftList<T>(source);
            return buffer.FromEnd(reverseIndex);
        }

        /// <summary>
        /// Gets the element at the specified index from the end (1-based) from SwiftList.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T FromEnd<T>(this SwiftList<T> list, int reverseIndex)
        {
            if (reverseIndex <= 0 || reverseIndex > list.Count)
                throw new ArgumentOutOfRangeException(nameof(reverseIndex));
            return list[list.Count - reverseIndex];
        }

        /// <summary>
        /// Returns the last item in the sequence.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T Last<T>(this IEnumerable<T> source) => source.FromEnd(1);

        /// <summary>
        /// Returns the second-to-last item in the sequence.
        /// </summary>
        public static T SecondToLast<T>(this IEnumerable<T> source) => source.FromEnd(2);
    }
}
